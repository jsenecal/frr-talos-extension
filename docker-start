#!/bin/bash

set -e

log() {
    echo -e "[$(date +%Y-%m-%d-%H:%M:%S)][frr] $*" >&2
}

# Load configuration from files only
log "Loading configuration from files..."

# Validate and load configuration
log "Validating configuration"
python3 /usr/local/bin/config_loader.py --validate || {
    log "Configuration validation failed"
    exit 1
}

# Generate JSON context for j2cli
log "Generating configuration context"
python3 /usr/local/bin/config_loader.py --json > /tmp/config.json
CONFIG_SOURCE="/tmp/config.json"

log "Configuration loaded from: ${CONFIG_SOURCE}"

# Use the FRR multi-peer template
FRR_TEMPLATE="/etc/frr/frr.conf.j2"
log "Using FRR template: ${FRR_TEMPLATE}"

# Extract network configuration from config file
log "Setting up network namespace for Cilium BGP peering"

# Extract values from JSON config
NAMESPACE_CILIUM=$(python3 -c "import json; c=json.load(open('/tmp/config.json')); print(c.get('bgp',{}).get('cilium',{}).get('namespace','cilium'))")
VETH_FRR=$(python3 -c "import json; c=json.load(open('/tmp/config.json')); print(c.get('network',{}).get('veth_names',{}).get('frr_side','veth-frr'))")
VETH_CILIUM=$(python3 -c "import json; c=json.load(open('/tmp/config.json')); print(c.get('network',{}).get('veth_names',{}).get('cilium_side','veth-cilium'))")
INTERFACE_MTU=$(python3 -c "import json; c=json.load(open('/tmp/config.json')); print(c.get('network',{}).get('interface_mtu',1500))")

# Extract peering IPs
PEER_IP_LOCAL=$(python3 -c "import json; c=json.load(open('/tmp/config.json')); print(c.get('bgp',{}).get('cilium',{}).get('peering',{}).get('ipv4',{}).get('local',''))")
PEER_IP_REMOTE=$(python3 -c "import json; c=json.load(open('/tmp/config.json')); print(c.get('bgp',{}).get('cilium',{}).get('peering',{}).get('ipv4',{}).get('remote',''))")
PEER_IP_PREFIX=$(python3 -c "import json; c=json.load(open('/tmp/config.json')); print(c.get('bgp',{}).get('cilium',{}).get('peering',{}).get('ipv4',{}).get('prefix',31))")

# Extract IPv6 if present
PEER_IPV6_LOCAL=$(python3 -c "import json; c=json.load(open('/tmp/config.json')); print(c.get('bgp',{}).get('cilium',{}).get('peering',{}).get('ipv6',{}).get('local',''))")
PEER_IPV6_REMOTE=$(python3 -c "import json; c=json.load(open('/tmp/config.json')); print(c.get('bgp',{}).get('cilium',{}).get('peering',{}).get('ipv6',{}).get('remote',''))")
PEER_IPV6_PREFIX=$(python3 -c "import json; c=json.load(open('/tmp/config.json')); print(c.get('bgp',{}).get('cilium',{}).get('peering',{}).get('ipv6',{}).get('prefix',126))")

# Create network namespace
/sbin/ip netns add ${NAMESPACE_CILIUM} || {
    log "Network namespace ${NAMESPACE_CILIUM} already exists"
}

log "Creating veth pair: ${VETH_CILIUM} <-> ${VETH_FRR}"

/sbin/ip link add ${VETH_CILIUM} type veth peer name ${VETH_FRR} || {
    log "Veth pair already exists"
}

# Move one end to the namespace
/sbin/ip link set ${VETH_CILIUM} netns ${NAMESPACE_CILIUM} || true

# Configure IPv4 addresses
if [ -n "${PEER_IP_LOCAL}" ] && [ -n "${PEER_IP_REMOTE}" ]; then
    log "Configuring IPv4 peering: ${PEER_IP_LOCAL} <-> ${PEER_IP_REMOTE}"
    /sbin/ip netns exec ${NAMESPACE_CILIUM} /sbin/ip a a ${PEER_IP_LOCAL}/${PEER_IP_PREFIX} dev ${VETH_CILIUM} || true
    /sbin/ip a a ${PEER_IP_REMOTE}/${PEER_IP_PREFIX} dev ${VETH_FRR} || true
fi

# Configure IPv6 addresses
if [ -n "${PEER_IPV6_LOCAL}" ] && [ -n "${PEER_IPV6_REMOTE}" ]; then
    log "Configuring IPv6 peering: ${PEER_IPV6_LOCAL} <-> ${PEER_IPV6_REMOTE}"
    /sbin/ip netns exec ${NAMESPACE_CILIUM} /sbin/ip -6 a a ${PEER_IPV6_LOCAL}/${PEER_IPV6_PREFIX} dev ${VETH_CILIUM} || true
    /sbin/ip -6 a a ${PEER_IPV6_REMOTE}/${PEER_IPV6_PREFIX} dev ${VETH_FRR} || true
fi

# Bring up interfaces
log "Bringing up interfaces with MTU ${INTERFACE_MTU}"
/sbin/ip link set ${VETH_FRR} up || true
/sbin/ip link set ${VETH_FRR} mtu ${INTERFACE_MTU} || true
/sbin/ip netns exec ${NAMESPACE_CILIUM} /sbin/ip link set ${VETH_CILIUM} up || true
/sbin/ip netns exec ${NAMESPACE_CILIUM} /sbin/ip link set ${VETH_CILIUM} mtu ${INTERFACE_MTU} || true

# Initialize /etc/frr if empty (first boot with bind mount)
if [ ! -f /etc/frr/.initialized ]; then
    log "Initializing /etc/frr directory (first boot)"
    # Copy defaults from backup to mounted directory
    cp -r /etc/frr.defaults/* /etc/frr/ 2>/dev/null || true
    touch /etc/frr/.initialized
fi

# Ensure daemons file exists
if [ ! -f /etc/frr/daemons ]; then
    cp /etc/frr.defaults/daemons /etc/frr/daemons
fi

# Generate FRR configuration
log "Generating FRR configuration from template: ${FRR_TEMPLATE}"

# Use the JSON context from config_loader
python3 /usr/local/bin/render_template.py ${FRR_TEMPLATE} ${CONFIG_SOURCE} /etc/frr/frr.conf

log "Generated FRR configuration:"
cat /etc/frr/frr.conf

# Create vtysh.conf if it doesn't exist
[ -r /etc/frr/vtysh.conf ] || touch /etc/frr/vtysh.conf

# Set ownership
chown -R frr:frr /etc/frr || true

# Enable syslog
log "Starting syslogd"
syslogd -n -O - &

# Start FRR
log "Starting FRR daemons (including BFD if enabled)"
/usr/lib/frr/frrinit.sh start

# Wait for daemons to start
sleep 5

# Check BFD status if configured
if grep -q "bfdd=true" /etc/frr/daemons 2>/dev/null; then
    log "Checking BFD daemon status"
    vtysh -c "show bfd peers" || true
fi

# Show process list
log "Current processes:"
ps -ef | grep -E "(bgpd|bfdd|zebra)" || true

# Monitoring loop with BFD status
MONITOR_INTERVAL=${MONITOR_INTERVAL:-60}
MONITOR_COUNT=${MONITOR_COUNT:-5}

count=0
while true; do
    if [ $count -lt ${MONITOR_COUNT} ]; then
        log "=== Status Check (${count}/${MONITOR_COUNT}) ==="

        # BGP status
        vtysh -c "show bgp vrf all summary wide" || true

        # BFD status if configured
        if grep -q "bfdd=true" /etc/frr/daemons 2>/dev/null; then
            log "BFD Peer Status:"
            vtysh -c "show bfd peers brief" || true
        fi

        # Routing table
        vtysh -c "show ip route summary" || true

        if [ -n "${PEER_IPV6_REMOTE}" ]; then
            vtysh -c "show ipv6 route summary" || true
        fi

        count=$((count + 1))
    fi

    sleep ${MONITOR_INTERVAL}
done